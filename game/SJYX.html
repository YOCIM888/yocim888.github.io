<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>未来感3D第一人称射击游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #000;
            color: #0ff;
            width: 100vw;
            height: 100vh;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            padding: 20px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(0, 255, 255, 0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .hud-item {
            background-color: rgba(0, 20, 40, 0.7);
            border: 1px solid #0ff;
            border-radius: 5px;
            padding: 10px 15px;
            margin-bottom: 10px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        #health-container, #ammo-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .health-bar, .ammo-bar {
            flex-grow: 1;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #f00, #0f0);
            transition: width 0.3s;
        }
        
        .ammo-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0, #0ff);
            transition: width 0.3s;
        }
        
        #score {
            font-size: 18px;
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        
        #weapon-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 14px;
            text-align: right;
        }
        
        #enemy-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #8ff;
            line-height: 1.5;
            max-width: 300px;
        }
        
        #game-over, #game-start {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #game-over {
            display: none;
        }
        
        .game-title {
            font-size: 48px;
            color: #0ff;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0ff;
            text-align: center;
        }
        
        .game-subtitle {
            font-size: 24px;
            color: #8ff;
            margin-bottom: 40px;
            text-align: center;
        }
        
        #final-score {
            font-size: 36px;
            color: #ff0;
            margin: 20px 0;
            text-shadow: 0 0 15px #ff0;
        }
        
        .btn {
            background: linear-gradient(45deg, #0066cc, #00ccff);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 18px;
            padding: 12px 30px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
        }
        
        .btn:hover {
            background: linear-gradient(45deg, #00ccff, #0066cc);
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.8);
            transform: scale(1.05);
        }
        
        #hit-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 3;
            transition: opacity 0.1s;
        }
        
        .hit-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
        }
        
        .hit-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: rgba(255, 50, 50, 0.7);
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            opacity: 0;
        }
        
        #message {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 4;
            text-align: center;
        }
        
        #radar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            background-color: rgba(0, 20, 40, 0.7);
            border: 2px solid #0ff;
            border-radius: 50%;
            overflow: hidden;
        }
        
        .radar-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background-color: #0ff;
            border-radius: 50%;
        }
        
        .radar-sweep {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 50%;
            background: linear-gradient(to bottom, transparent, #0ff);
            transform-origin: bottom center;
        }
        
        .radar-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: #f0f;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="hud">
            <div id="crosshair"></div>
            
            <div style="position: absolute; top: 20px; left: 20px;">
                <div class="hud-item" id="health-container">
                    <span>生命值</span>
                    <div class="health-bar">
                        <div class="health-fill" id="health-bar"></div>
                    </div>
                    <span id="health-text">100</span>
                </div>
                
                <div class="hud-item" id="ammo-container">
                    <span>能量</span>
                    <div class="ammo-bar">
                        <div class="ammo-fill" id="ammo-bar"></div>
                    </div>
                    <span id="ammo-text">100</span>
                </div>
                
                <div class="hud-item" id="score">
                    得分: <span id="score-value">0</span>
                </div>
            </div>
            
            <div id="enemy-counter">
                敌人剩余: <span id="enemy-count">5</span>
            </div>
            
            <div id="weapon-info">
                <div>武器: <span id="weapon-name">等离子步枪</span></div>
                <div>模式: <span id="weapon-mode">自动</span></div>
            </div>
            
            <div id="radar">
                <div class="radar-center"></div>
                <div class="radar-sweep" id="radar-sweep"></div>
            </div>
            
            <div id="instructions">
                WASD - 移动<br>
                鼠标 - 瞄准/射击<br>
                R - 重新装弹<br>
                空格键 - 跳跃<br>
                F - 切换武器模式<br>
                1/2 - 切换武器<br>
                ESC - 暂停游戏
            </div>
        </div>
        
        <div id="hit-effect">
            <div class="hit-flash"></div>
            <div class="hit-indicator">命中!</div>
        </div>
        
        <div id="message"></div>
        
        <div id="game-start">
            <h1 class="game-title">未来战争: 觉醒</h1>
            <p class="game-subtitle">第一人称射击体验</p>
            <button class="btn" id="start-btn">开始游戏</button>
            <p style="margin-top: 30px; color: #8ff; max-width: 600px; text-align: center;">
                在未来的战场上，消灭所有敌人并生存下来。<br>
                使用你的高科技武器击败敌人，注意你的生命值和能量。
            </p>
        </div>
        
        <div id="game-over">
            <h1 class="game-title">游戏结束</h1>
            <p class="game-subtitle">你的战斗已经结束</p>
            <div id="final-score">得分: 0</div>
            <button class="btn" id="restart-btn">重新开始</button>
            <button class="btn" id="menu-btn">返回菜单</button>
        </div>
    </div>

    <script>
        // 游戏配置
        const config = {
            canvas: document.getElementById('game-canvas'),
            hud: {
                healthText: document.getElementById('health-text'),
                healthBar: document.getElementById('health-bar'),
                ammoText: document.getElementById('ammo-text'),
                ammoBar: document.getElementById('ammo-bar'),
                scoreValue: document.getElementById('score-value'),
                enemyCount: document.getElementById('enemy-count'),
                weaponName: document.getElementById('weapon-name'),
                weaponMode: document.getElementById('weapon-mode')
            },
            gameStates: {
                start: document.getElementById('game-start'),
                over: document.getElementById('game-over'),
                playing: false
            },
            elements: {
                hitEffect: document.getElementById('hit-effect'),
                hitIndicator: document.querySelector('.hit-indicator'),
                radarSweep: document.getElementById('radar-sweep'),
                message: document.getElementById('message')
            }
        };

        // 游戏状态
        const gameState = {
            score: 0,
            health: 100,
            maxHealth: 100,
            ammo: 100,
            maxAmmo: 100,
            enemies: 5,
            totalEnemies: 5,
            weapon: {
                name: '等离子步枪',
                mode: '自动',
                damage: 25,
                fireRate: 200, // 毫秒
                lastShot: 0
            },
            player: {
                x: 0,
                y: 0,
                angle: 0,
                moving: false,
                keys: {}
            },
            enemies: [],
            projectiles: [],
            particles: [],
            radarDots: [],
            gameTime: 0
        };

        // 初始化游戏
        function initGame() {
            const canvas = config.canvas;
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas大小
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // 初始化敌人
            initEnemies();
            
            // 初始化雷达点
            initRadarDots();
            
            // 显示开始游戏界面
            config.gameStates.start.style.display = 'flex';
            config.gameStates.over.style.display = 'none';
            
            // 开始游戏循环
            gameLoop();
        }

        // 初始化敌人
        function initEnemies() {
            gameState.enemies = [];
            gameState.enemies = 5;
            gameState.totalEnemies = 5;
            
            // 创建敌人位置（在画布周围）
            for (let i = 0; i < gameState.totalEnemies; i++) {
                const angle = (i / gameState.totalEnemies) * Math.PI * 2;
                const distance = 300 + Math.random() * 200;
                
                gameState.enemies.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance,
                    size: 30 + Math.random() * 20,
                    health: 100,
                    maxHealth: 100,
                    angle: Math.random() * Math.PI * 2,
                    speed: 1 + Math.random() * 2,
                    type: Math.floor(Math.random() * 3), // 0, 1, 2 不同类型的敌人
                    lastShot: 0,
                    shotDelay: 1000 + Math.random() * 2000
                });
            }
            
            updateEnemyCounter();
        }

        // 初始化雷达点
        function initRadarDots() {
            gameState.radarDots = [];
            
            // 创建一些随机雷达点
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                
                gameState.radarDots.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance,
                    type: Math.random() > 0.7 ? 'enemy' : 'neutral'
                });
            }
        }

        // 游戏主循环
        function gameLoop() {
            if (!config.gameStates.playing) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            const canvas = config.canvas;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 清空画布
            ctx.fillStyle = '#001020';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制3D场景
            draw3DScene(ctx, width, height);
            
            // 更新游戏状态
            updateGameState();
            
            // 更新HUD
            updateHUD();
            
            // 更新雷达扫描
            updateRadar();
            
            // 继续游戏循环
            requestAnimationFrame(gameLoop);
        }

        // 绘制3D场景
        function draw3DScene(ctx, width, height) {
            // 绘制地板
            drawFloor(ctx, width, height);
            
            // 绘制墙壁
            drawWalls(ctx, width, height);
            
            // 绘制敌人
            drawEnemies(ctx, width, height);
            
            // 绘制子弹/粒子效果
            drawProjectiles(ctx, width, height);
            
            // 绘制天空/背景
            drawSky(ctx, width, height);
        }

        // 绘制地板
        function drawFloor(ctx, width, height) {
            // 简单的网格地板
            const gridSize = 50;
            const horizon = height / 2;
            
            // 地板颜色
            const floorGradient = ctx.createLinearGradient(0, horizon, 0, height);
            floorGradient.addColorStop(0, '#001a33');
            floorGradient.addColorStop(1, '#003366');
            
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, horizon, width, height - horizon);
            
            // 绘制网格
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 水平线
            for (let i = 1; i < 10; i++) {
                const y = horizon + (i / 10) * (height - horizon);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // 垂直线
            const centerX = width / 2;
            for (let i = -5; i <= 5; i++) {
                const x = centerX + (i * 100);
                const perspective = Math.max(0.1, 1 - Math.abs(i) * 0.1);
                const startY = horizon;
                const endY = height;
                
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
        }

        // 绘制墙壁
        function drawWalls(ctx, width, height) {
            const horizon = height / 2;
            const wallHeight = 200;
            
            // 左侧墙壁
            const leftWallGradient = ctx.createLinearGradient(0, 0, width * 0.2, 0);
            leftWallGradient.addColorStop(0, '#004488');
            leftWallGradient.addColorStop(1, '#002244');
            
            ctx.fillStyle = leftWallGradient;
            ctx.fillRect(0, horizon - wallHeight, width * 0.2, wallHeight);
            
            // 右侧墙壁
            const rightWallGradient = ctx.createLinearGradient(width * 0.8, 0, width, 0);
            rightWallGradient.addColorStop(0, '#002244');
            rightWallGradient.addColorStop(1, '#004488');
            
            ctx.fillStyle = rightWallGradient;
            ctx.fillRect(width * 0.8, horizon - wallHeight, width * 0.2, wallHeight);
            
            // 墙壁细节
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            
            // 左侧墙壁细节
            for (let i = 0; i < 5; i++) {
                const x = (width * 0.2) * (i / 5);
                ctx.beginPath();
                ctx.moveTo(x, horizon - wallHeight);
                ctx.lineTo(x, horizon);
                ctx.stroke();
            }
            
            // 右侧墙壁细节
            for (let i = 0; i < 5; i++) {
                const x = width * 0.8 + (width * 0.2) * (i / 5);
                ctx.beginPath();
                ctx.moveTo(x, horizon - wallHeight);
                ctx.lineTo(x, horizon);
                ctx.stroke();
            }
        }

        // 绘制敌人
        function drawEnemies(ctx, width, height) {
            const horizon = height / 2;
            
            gameState.enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                // 计算敌人在屏幕上的位置
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算角度
                let angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // 将角度限制在 -π 到 π 之间
                while (angle > Math.PI) angle -= Math.PI * 2;
                while (angle < -Math.PI) angle += Math.PI * 2;
                
                // 如果敌人在视野范围内
                if (Math.abs(angle) < Math.PI / 2 && distance > 10) {
                    // 计算透视投影
                    const screenX = width / 2 + (angle * width / Math.PI);
                    const size = (enemy.size * height) / distance;
                    const screenY = horizon + (height / distance) * 50;
                    
                    // 绘制敌人
                    const enemyTypeColors = ['#ff3366', '#33ff66', '#3366ff'];
                    const enemyColor = enemyTypeColors[enemy.type];
                    
                    // 敌人主体
                    ctx.fillStyle = enemyColor;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - size / 2, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 敌人细节
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - size / 2, size / 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 敌人生命条
                    const healthPercent = enemy.health / enemy.maxHealth;
                    const barWidth = size;
                    const barHeight = 5;
                    const barX = screenX - barWidth / 2;
                    const barY = screenY - size;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    // 如果敌人正在射击，添加特效
                    if (Date.now() - enemy.lastShot < 200) {
                        ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY - size / 2, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }

        // 绘制子弹/粒子效果
        function drawProjectiles(ctx, width, height) {
            const horizon = height / 2;
            
            // 绘制子弹
            gameState.projectiles.forEach((proj, index) => {
                // 计算子弹在屏幕上的位置
                const dx = proj.x - gameState.player.x;
                const dy = proj.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算角度
                let angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // 将角度限制在 -π 到 π 之间
                while (angle > Math.PI) angle -= Math.PI * 2;
                while (angle < -Math.PI) angle += Math.PI * 2;
                
                // 如果子弹在视野范围内
                if (Math.abs(angle) < Math.PI / 2 && distance > 10) {
                    // 计算透视投影
                    const screenX = width / 2 + (angle * width / Math.PI);
                    const size = Math.max(2, 10 - distance / 50);
                    const screenY = horizon + (height / distance) * 50;
                    
                    // 绘制子弹
                    ctx.fillStyle = proj.color || '#ff0';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 子弹轨迹
                    ctx.strokeStyle = proj.color || '#ff0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(screenX - proj.vx * 5, screenY - proj.vy * 5);
                    ctx.stroke();
                }
            });
            
            // 绘制粒子效果
            gameState.particles.forEach((particle, index) => {
                // 计算粒子在屏幕上的位置
                const dx = particle.x - gameState.player.x;
                const dy = particle.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算角度
                let angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // 将角度限制在 -π 到 π 之间
                while (angle > Math.PI) angle -= Math.PI * 2;
                while (angle < -Math.PI) angle += Math.PI * 2;
                
                // 如果粒子在视野范围内
                if (Math.abs(angle) < Math.PI / 2 && distance > 10) {
                    // 计算透视投影
                    const screenX = width / 2 + (angle * width / Math.PI);
                    const size = particle.size * (1 - particle.life / particle.maxLife);
                    const screenY = horizon + (height / distance) * 50;
                    
                    // 绘制粒子
                    ctx.globalAlpha = particle.life / particle.maxLife;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
        }

        // 绘制天空/背景
        function drawSky(ctx, width, height) {
            const horizon = height / 2;
            
            // 天空渐变
            const skyGradient = ctx.createLinearGradient(0, 0, 0, horizon);
            skyGradient.addColorStop(0, '#000811');
            skyGradient.addColorStop(1, '#001a33');
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, horizon);
            
            // 星星
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * width;
                const y = Math.random() * horizon;
                const size = Math.random() * 1.5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 远处的行星/月亮
            ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(width * 0.8, horizon * 0.3, 40, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(200, 150, 100, 0.2)';
            ctx.beginPath();
            ctx.arc(width * 0.2, horizon * 0.4, 30, 0, Math.PI * 2);
            ctx.fill();
        }

        // 更新游戏状态
        function updateGameState() {
            const currentTime = Date.now();
            gameState.gameTime += 16; // 假设60fps
            
            // 更新玩家位置
            updatePlayerPosition();
            
            // 更新敌人
            updateEnemies();
            
            // 更新子弹
            updateProjectiles();
            
            // 更新粒子效果
            updateParticles();
            
            // 检查游戏结束条件
            if (gameState.health <= 0) {
                endGame(false);
            }
            
            // 检查胜利条件
            if (gameState.enemies <= 0) {
                showMessage("任务完成! 所有敌人已被消灭!");
                setTimeout(() => {
                    endGame(true);
                }, 3000);
            }
        }

        // 更新玩家位置
        function updatePlayerPosition() {
            const speed = 5;
            const angle = gameState.player.angle;
            
            if (gameState.player.keys['w'] || gameState.player.keys['ArrowUp']) {
                gameState.player.x += Math.cos(angle) * speed;
                gameState.player.y += Math.sin(angle) * speed;
            }
            if (gameState.player.keys['s'] || gameState.player.keys['ArrowDown']) {
                gameState.player.x -= Math.cos(angle) * speed;
                gameState.player.y -= Math.sin(angle) * speed;
            }
            if (gameState.player.keys['a'] || gameState.player.keys['ArrowLeft']) {
                gameState.player.x += Math.cos(angle - Math.PI/2) * speed;
                gameState.player.y += Math.sin(angle - Math.PI/2) * speed;
            }
            if (gameState.player.keys['d'] || gameState.player.keys['ArrowRight']) {
                gameState.player.x += Math.cos(angle + Math.PI/2) * speed;
                gameState.player.y += Math.sin(angle + Math.PI/2) * speed;
            }
            
            // 限制玩家移动范围
            const maxDistance = 500;
            const distance = Math.sqrt(gameState.player.x * gameState.player.x + gameState.player.y * gameState.player.y);
            if (distance > maxDistance) {
                gameState.player.x = (gameState.player.x / distance) * maxDistance;
                gameState.player.y = (gameState.player.y / distance) * maxDistance;
            }
        }

        // 更新敌人
        function updateEnemies() {
            const currentTime = Date.now();
            
            gameState.enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                // 敌人移动
                enemy.angle += (Math.random() - 0.5) * 0.1;
                enemy.x += Math.cos(enemy.angle) * enemy.speed;
                enemy.y += Math.sin(enemy.angle) * enemy.speed;
                
                // 限制敌人移动范围
                const maxDistance = 600;
                const distance = Math.sqrt(enemy.x * enemy.x + enemy.y * enemy.y);
                if (distance > maxDistance) {
                    enemy.x = (enemy.x / distance) * maxDistance;
                    enemy.y = (enemy.y / distance) * maxDistance;
                    enemy.angle = Math.atan2(enemy.y, enemy.x) + Math.PI;
                }
                
                // 敌人射击
                if (currentTime - enemy.lastShot > enemy.shotDelay) {
                    const dx = gameState.player.x - enemy.x;
                    const dy = gameState.player.y - enemy.y;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    
                    // 如果玩家在射程内
                    if (distToPlayer < 400) {
                        enemy.lastShot = currentTime;
                        
                        // 创建敌人子弹
                        const angle = Math.atan2(dy, dx);
                        gameState.projectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle) * 10,
                            vy: Math.sin(angle) * 10,
                            damage: 10,
                            isEnemy: true,
                            color: '#f00'
                        });
                        
                        // 玩家有几率被击中
                        if (Math.random() > 0.7) {
                            takeDamage(10);
                        }
                    }
                }
                
                // 检查子弹是否击中敌人
                gameState.projectiles.forEach((proj, projIndex) => {
                    if (proj.isEnemy) return;
                    
                    const dx = proj.x - enemy.x;
                    const dy = proj.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size) {
                        // 击中敌人
                        enemy.health -= proj.damage;
                        
                        // 创建击中效果
                        createHitEffect(enemy.x, enemy.y, '#ff0');
                        
                        // 移除子弹
                        gameState.projectiles.splice(projIndex, 1);
                        
                        // 如果敌人死亡
                        if (enemy.health <= 0) {
                            gameState.enemies--;
                            gameState.score += 100;
                            updateEnemyCounter();
                            updateScore();
                            
                            // 创建死亡效果
                            for (let i = 0; i < 10; i++) {
                                gameState.particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    size: 3 + Math.random() * 5,
                                    color: '#ff0',
                                    life: 30 + Math.random() * 30,
                                    maxLife: 60
                                });
                            }
                        }
                    }
                });
            });
        }

        // 更新子弹
        function updateProjectiles() {
            // 更新子弹位置
            gameState.projectiles.forEach((proj, index) => {
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                // 检查子弹是否超出范围
                const distance = Math.sqrt(proj.x * proj.x + proj.y * proj.y);
                if (distance > 800) {
                    gameState.projectiles.splice(index, 1);
                }
                
                // 如果是敌人子弹，检查是否击中玩家
                if (proj.isEnemy) {
                    const dx = proj.x - gameState.player.x;
                    const dy = proj.y - gameState.player.y;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distToPlayer < 20) {
                        // 击中玩家
                        takeDamage(proj.damage);
                        gameState.projectiles.splice(index, 1);
                        createHitEffect(proj.x, proj.y, '#f00');
                    }
                }
            });
        }

        // 更新粒子效果
        function updateParticles() {
            gameState.particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                // 移除死亡的粒子
                if (particle.life <= 0) {
                    gameState.particles.splice(index, 1);
                }
            });
        }

        // 更新HUD
        function updateHUD() {
            // 更新生命值
            const healthPercent = gameState.health / gameState.maxHealth;
            config.hud.healthText.textContent = Math.max(0, Math.floor(gameState.health));
            config.hud.healthBar.style.width = `${healthPercent * 100}%`;
            
            // 更新能量
            const ammoPercent = gameState.ammo / gameState.maxAmmo;
            config.hud.ammoText.textContent = Math.max(0, Math.floor(gameState.ammo));
            config.hud.ammoBar.style.width = `${ammoPercent * 100}%`;
            
            // 更新武器信息
            config.hud.weaponName.textContent = gameState.weapon.name;
            config.hud.weaponMode.textContent = gameState.weapon.mode;
        }

        // 更新雷达
        function updateRadar() {
            const sweep = config.elements.radarSweep;
            const rotation = (gameState.gameTime / 50) % 360;
            sweep.style.transform = `rotate(${rotation}deg)`;
            
            // 清除旧的点
            document.querySelectorAll('.radar-dot').forEach(dot => dot.remove());
            
            // 添加雷达点
            gameState.radarDots.forEach(dot => {
                const radar = document.getElementById('radar');
                const radarDot = document.createElement('div');
                radarDot.className = 'radar-dot';
                radarDot.style.left = `calc(50% + ${dot.x / 2}px)`;
                radarDot.style.top = `calc(50% + ${dot.y / 2}px)`;
                radarDot.style.backgroundColor = dot.type === 'enemy' ? '#f0f' : '#0ff';
                radar.appendChild(radarDot);
            });
            
            // 添加敌人位置到雷达
            gameState.enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                const radar = document.getElementById('radar');
                const radarDot = document.createElement('div');
                radarDot.className = 'radar-dot';
                radarDot.style.left = `calc(50% + ${enemy.x / 10}px)`;
                radarDot.style.top = `calc(50% + ${enemy.y / 10}px)`;
                radarDot.style.backgroundColor = '#f00';
                radarDot.style.width = '8px';
                radarDot.style.height = '8px';
                radar.appendChild(radarDot);
            });
        }

        // 更新敌人计数器
        function updateEnemyCounter() {
            config.hud.enemyCount.textContent = gameState.enemies;
        }

        // 更新分数
        function updateScore() {
            config.hud.scoreValue.textContent = gameState.score;
        }

        // 显示消息
        function showMessage(text) {
            const message = config.elements.message;
            message.textContent = text;
            message.style.opacity = 1;
            
            setTimeout(() => {
                message.style.opacity = 0;
            }, 3000);
        }

        // 创建击中效果
        function createHitEffect(x, y, color) {
            // 屏幕击中效果
            config.elements.hitEffect.style.opacity = 0.7;
            config.elements.hitIndicator.style.opacity = 1;
            
            setTimeout(() => {
                config.elements.hitEffect.style.opacity = 0;
                config.elements.hitIndicator.style.opacity = 0;
            }, 100);
            
            // 创建粒子效果
            for (let i = 0; i < 5; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: 2 + Math.random() * 3,
                    color: color,
                    life: 20 + Math.random() * 20,
                    maxLife: 40
                });
            }
        }

        // 玩家受到伤害
        function takeDamage(amount) {
            gameState.health -= amount;
            if (gameState.health < 0) gameState.health = 0;
            
            // 显示伤害效果
            createHitEffect(gameState.player.x, gameState.player.y, '#f00');
            
            // 更新HUD
            updateHUD();
        }

        // 玩家射击
        function playerShoot() {
            const currentTime = Date.now();
            
            // 检查是否可以射击
            if (currentTime - gameState.weapon.lastShot < gameState.weapon.fireRate) return;
            
            // 检查是否有弹药
            if (gameState.ammo <= 0) {
                showMessage("能量不足!");
                return;
            }
            
            // 消耗弹药
            gameState.ammo -= 2;
            if (gameState.ammo < 0) gameState.ammo = 0;
            
            // 更新上次射击时间
            gameState.weapon.lastShot = currentTime;
            
            // 创建子弹
            const bulletCount = gameState.weapon.mode === '散射' ? 5 : 1;
            const spread = gameState.weapon.mode === '散射' ? 0.2 : 0.05;
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = gameState.player.angle + (Math.random() - 0.5) * spread;
                
                gameState.projectiles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(angle) * 15,
                    vy: Math.sin(angle) * 15,
                    damage: gameState.weapon.damage / (bulletCount > 1 ? 2 : 1),
                    isEnemy: false,
                    color: '#0ff'
                });
            }
            
            // 创建射击效果
            for (let i = 0; i < 3; i++) {
                gameState.particles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(gameState.player.angle) * 10 + (Math.random() - 0.5) * 3,
                    vy: Math.sin(gameState.player.angle) * 10 + (Math.random() - 0.5) * 3,
                    size: 1 + Math.random() * 2,
                    color: '#0ff',
                    life: 10 + Math.random() * 10,
                    maxLife: 20
                });
            }
            
            // 更新HUD
            updateHUD();
        }

        // 重新装弹
        function reload() {
            if (gameState.ammo >= gameState.maxAmmo) return;
            
            gameState.ammo = gameState.maxAmmo;
            showMessage("能量已充满!");
            updateHUD();
        }

        // 切换武器模式
        function toggleWeaponMode() {
            const modes = ['自动', '散射', '狙击'];
            const currentIndex = modes.indexOf(gameState.weapon.mode);
            const nextIndex = (currentIndex + 1) % modes.length;
            
            gameState.weapon.mode = modes[nextIndex];
            
            // 根据模式调整武器属性
            if (gameState.weapon.mode === '散射') {
                gameState.weapon.damage = 15;
                gameState.weapon.fireRate = 500;
            } else if (gameState.weapon.mode === '狙击') {
                gameState.weapon.damage = 50;
                gameState.weapon.fireRate = 1000;
            } else {
                gameState.weapon.damage = 25;
                gameState.weapon.fireRate = 200;
            }
            
            showMessage(`武器模式: ${gameState.weapon.mode}`);
            updateHUD();
        }

        // 切换武器
        function switchWeapon(weaponIndex) {
            const weapons = [
                { name: '等离子步枪', color: '#0ff' },
                { name: '激光枪', color: '#f0f' },
                { name: '离子炮', color: '#ff0' }
            ];
            
            if (weaponIndex >= 0 && weaponIndex < weapons.length) {
                gameState.weapon.name = weapons[weaponIndex].name;
                showMessage(`武器切换: ${gameState.weapon.name}`);
                updateHUD();
            }
        }

        // 开始游戏
        function startGame() {
            console.log("开始游戏按钮被点击");
            config.gameStates.playing = true;
            config.gameStates.start.style.display = 'none';
            
            // 重置游戏状态
            gameState.score = 0;
            gameState.health = 100;
            gameState.ammo = 100;
            gameState.enemies = 5;
            gameState.totalEnemies = 5;
            gameState.player.x = 0;
            gameState.player.y = 0;
            gameState.player.angle = 0;
            gameState.projectiles = [];
            gameState.particles = [];
            
            // 初始化敌人
            initEnemies();
            
            // 更新HUD
            updateScore();
            updateHUD();
            updateEnemyCounter();
            
            showMessage("游戏开始! 消灭所有敌人!");
        }

        // 结束游戏
        function endGame(isVictory) {
            config.gameStates.playing = false;
            
            // 显示最终分数
            document.getElementById('final-score').textContent = `得分: ${gameState.score}`;
            
            // 显示游戏结束界面
            config.gameStates.over.style.display = 'flex';
            
            if (isVictory) {
                document.querySelector('#game-over .game-title').textContent = "任务完成!";
                document.querySelector('#game-over .game-subtitle').textContent = "所有敌人已被消灭!";
            }
        }

        // 事件监听器
        function setupEventListeners() {
            const canvas = config.canvas;
            
            // 鼠标移动 - 控制视角
            canvas.addEventListener('mousemove', (e) => {
                if (!config.gameStates.playing) return;
                
                const sensitivity = 0.005;
                gameState.player.angle += e.movementX * sensitivity;
                
                // 限制角度在合理范围内
                if (gameState.player.angle > Math.PI) gameState.player.angle -= Math.PI * 2;
                if (gameState.player.angle < -Math.PI) gameState.player.angle += Math.PI * 2;
            });
            
            // 鼠标点击 - 射击
            canvas.addEventListener('mousedown', (e) => {
                if (!config.gameStates.playing) return;
                
                if (e.button === 0) { // 左键
                    playerShoot();
                }
            });
            
            // 键盘控制
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                gameState.player.keys[key] = true;
                
                if (!config.gameStates.playing) return;
                
                switch(key) {
                    case 'r': // 重新装弹
                        reload();
                        break;
                    case 'f': // 切换武器模式
                        toggleWeaponMode();
                        break;
                    case '1': // 切换武器1
                        switchWeapon(0);
                        break;
                    case '2': // 切换武器2
                        switchWeapon(1);
                        break;
                    case 'escape': // 暂停游戏
                        config.gameStates.playing = false;
                        showMessage("游戏已暂停");
                        break;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                gameState.player.keys[key] = false;
            });
            
            // 修复：正确绑定开始游戏按钮事件
            document.getElementById('start-btn').addEventListener('click', startGame);
            
            // 重新开始按钮
            document.getElementById('restart-btn').addEventListener('click', () => {
                config.gameStates.over.style.display = 'none';
                startGame();
            });
            
            // 返回菜单按钮
            document.getElementById('menu-btn').addEventListener('click', () => {
                config.gameStates.over.style.display = 'none';
                config.gameStates.start.style.display = 'flex';
                config.gameStates.playing = false;
            });
            
            // 窗口大小调整
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
            
            // 请求指针锁定
            canvas.addEventListener('click', () => {
                if (config.gameStates.playing) {
                    canvas.requestPointerLock();
                }
            });
        }

        // 初始化
        window.onload = function() {
            console.log("页面加载完成，初始化游戏");
            initGame();
            setupEventListeners();
        };
    </script>
</body>
</html>