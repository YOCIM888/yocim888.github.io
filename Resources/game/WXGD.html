<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>未来战争: 觉醒 - 第一人称射击游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #000;
            color: #0ff;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            padding: 20px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.1s;
        }
        
        #crosshair.shooting {
            transform: translate(-50%, -50%) scale(1.3);
            border-color: rgba(255, 255, 0, 0.8);
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(0, 255, 255, 0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .hud-item {
            background-color: rgba(0, 20, 40, 0.7);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 12px 18px;
            margin-bottom: 12px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.3s;
        }
        
        .hud-item:hover {
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
        }
        
        #health-container, #ammo-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .hud-label {
            font-size: 14px;
            color: #8ff;
            min-width: 50px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .health-bar, .ammo-bar {
            flex-grow: 1;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0040, #00ff80);
            border-radius: 6px;
            transition: width 0.3s, background 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 128, 0.5);
        }
        
        .ammo-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff8000, #00ffff);
            border-radius: 6px;
            transition: width 0.3s, background 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .hud-value {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            min-width: 45px;
            text-align: right;
        }
        
        #score-container {
            text-align: center;
        }
        
        #score {
            font-size: 20px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        
        #score-value {
            color: #ff0;
            font-size: 24px;
        }
        
        #enemy-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 18px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #f0f;
        }
        
        #wave-info {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 14px;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
        }
        
        #weapon-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            font-size: 14px;
            line-height: 1.8;
        }
        
        .weapon-detail {
            background-color: rgba(0, 20, 40, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid #0ff;
            margin-bottom: 8px;
            backdrop-filter: blur(5px);
        }
        
        #radar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 160px;
            height: 160px;
            background-color: rgba(0, 20, 40, 0.8);
            border: 2px solid #0ff;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        .radar-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background-color: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 10px #0ff;
        }
        
        .radar-sweep {
            position: absolute;
            top: 0;
            left: 50%;
            width: 3px;
            height: 50%;
            background: linear-gradient(to bottom, transparent, rgba(0, 255, 255, 0.8));
            transform-origin: bottom center;
            animation: radarSweep 2s linear infinite;
        }
        
        @keyframes radarSweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .radar-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        .radar-ring-1 { width: 53px; height: 53px; }
        .radar-ring-2 { width: 106px; height: 106px; }
        
        .radar-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px currentColor;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            color: #8ff;
            line-height: 1.8;
            max-width: 220px;
            background-color: rgba(0, 20, 40, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .key {
            display: inline-block;
            background: rgba(0, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 2px;
            border: 1px solid rgba(0, 255, 255, 0.4);
            font-weight: bold;
        }
        
        #game-over, #game-start {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #game-over {
            display: none;
        }
        
        .game-title {
            font-size: 56px;
            color: #0ff;
            margin-bottom: 20px;
            text-shadow: 0 0 30px #0ff, 0 0 60px rgba(0, 255, 255, 0.5);
            text-align: center;
            letter-spacing: 5px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 30px #0ff, 0 0 60px rgba(0, 255, 255, 0.5); }
            to { text-shadow: 0 0 50px #0ff, 0 0 100px rgba(0, 255, 255, 0.8); }
        }
        
        .game-subtitle {
            font-size: 28px;
            color: #8ff;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 3px;
        }
        
        #final-score {
            font-size: 42px;
            color: #ff0;
            margin: 25px 0;
            text-shadow: 0 0 20px #ff0;
        }
        
        .stats-container {
            display: flex;
            gap: 30px;
            margin: 20px 0;
        }
        
        .stat-item {
            text-align: center;
            color: #0f0;
            font-size: 16px;
        }
        
        .stat-value {
            font-size: 28px;
            color: #0ff;
            display: block;
            margin-top: 5px;
        }
        
        .btn {
            background: linear-gradient(135deg, #0066cc, #00ccff);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 18px;
            padding: 15px 40px;
            margin: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: auto;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #00ccff, #0066cc);
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.8);
            transform: scale(1.08);
        }
        
        #hit-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 3;
            transition: opacity 0.1s;
        }
        
        .hit-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
        }
        
        .hit-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: rgba(255, 50, 50, 0.9);
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            opacity: 0;
            font-weight: bold;
        }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0) 100%);
            transition: background 0.2s;
        }
        
        #message {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 4;
            text-align: center;
            pointer-events: none;
        }
        
        #message.show {
            opacity: 1;
            transform: translateX(-50%) scale(1.1);
        }
        
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        .pause-title {
            font-size: 48px;
            color: #0ff;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0ff;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="damage-overlay"></div>
        
        <div id="hud">
            <div id="crosshair"></div>
            
            <div style="position: absolute; top: 20px; left: 20px;">
                <div class="hud-item" id="health-container">
                    <span class="hud-label">生命</span>
                    <div class="health-bar">
                        <div class="health-fill" id="health-bar"></div>
                    </div>
                    <span class="hud-value" id="health-text">100</span>
                </div>
                
                <div class="hud-item" id="ammo-container">
                    <span class="hud-label">能量</span>
                    <div class="ammo-bar">
                        <div class="ammo-fill" id="ammo-bar"></div>
                    </div>
                    <span class="hud-value" id="ammo-text">100</span>
                </div>
                
                <div class="hud-item" id="score-container">
                    <div id="score">得分: <span id="score-value">0</span></div>
                </div>
            </div>
            
            <div id="enemy-counter">
                敌人: <span id="enemy-count">0</span>
            </div>
            
            <div id="wave-info">
                波次: <span id="wave-count">1</span>
            </div>
            
            <div id="weapon-info">
                <div class="weapon-detail">
                    <div>武器: <span id="weapon-name">等离子步枪</span></div>
                    <div>模式: <span id="weapon-mode">自动</span></div>
                    <div>伤害: <span id="weapon-damage">25</span></div>
                </div>
            </div>
            
            <div id="radar">
                <div class="radar-ring radar-ring-1"></div>
                <div class="radar-ring radar-ring-2"></div>
                <div class="radar-center"></div>
                <div class="radar-sweep" id="radar-sweep"></div>
            </div>
            
            <div id="instructions">
                <div style="margin-bottom: 10px; color: #0ff; font-weight: bold;">操作说明</div>
                <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 移动<br>
                <span class="key">鼠标</span> 瞄准/射击<br>
                <span class="key">R</span> 能量填充<br>
                <span class="key">空格</span> 跳跃<br>
                <span class="key">F</span> 切换模式<br>
                <span class="key">1</span><span class="key">2</span><span class="key">3</span> 切换武器<br>
                <span class="key">ESC</span> 暂停
            </div>
        </div>
        
        <div id="hit-effect">
            <div class="hit-flash"></div>
            <div class="hit-indicator">CRITICAL!</div>
        </div>
        
        <div id="message"></div>
        
        <div id="pause-overlay">
            <h1 class="pause-title">游戏暂停</h1>
            <button class="btn" id="resume-btn">继续游戏</button>
            <button class="btn" id="quit-btn">返回主菜单</button>
        </div>
        
        <div id="game-start">
            <h1 class="game-title">未来战争: 觉醒</h1>
            <p class="game-subtitle">第一人称射击体验</p>
            <button class="btn" id="start-btn">开始游戏</button>
            <div style="margin-top: 30px; color: #8ff; max-width: 500px; text-align: center; line-height: 1.8;">
                在未来的战场上，消灭所有敌人并生存下来。<br>
                面对不同类型的敌人，使用高科技武器击败它们！<br>
                <span style="color: #0f0;">完成任务可获得额外奖励！</span>
            </div>
        </div>
        
        <div id="game-over">
            <h1 class="game-title" id="game-over-title">游戏结束</h1>
            <p class="game-subtitle" id="game-over-subtitle">你的战斗已经结束</p>
            <div id="final-score">得分: 0</div>
            <div class="stats-container">
                <div class="stat-item">
                    击杀数
                    <span class="stat-value" id="kill-count">0</span>
                </div>
                <div class="stat-item">
                    波次
                    <span class="stat-value" id="final-wave">1</span>
                </div>
                <div class="stat-item">
                    命中率
                    <span class="stat-value" id="accuracy">0%</span>
                </div>
            </div>
            <button class="btn" id="restart-btn">再来一局</button>
            <button class="btn" id="menu-btn">返回主菜单</button>
        </div>
    </div>

    <script>
        // 游戏配置
        const config = {
            canvas: document.getElementById('game-canvas'),
            hud: {
                healthText: document.getElementById('health-text'),
                healthBar: document.getElementById('health-bar'),
                ammoText: document.getElementById('ammo-text'),
                ammoBar: document.getElementById('ammo-bar'),
                scoreValue: document.getElementById('score-value'),
                enemyCount: document.getElementById('enemy-count'),
                waveCount: document.getElementById('wave-count'),
                weaponName: document.getElementById('weapon-name'),
                weaponMode: document.getElementById('weapon-mode'),
                weaponDamage: document.getElementById('weapon-damage')
            },
            gameStates: {
                start: document.getElementById('game-start'),
                over: document.getElementById('game-over'),
                pause: document.getElementById('pause-overlay'),
                playing: false
            },
            elements: {
                hitEffect: document.getElementById('hit-effect'),
                hitIndicator: document.querySelector('.hit-indicator'),
                radarSweep: document.getElementById('radar-sweep'),
                message: document.getElementById('message'),
                crosshair: document.getElementById('crosshair'),
                damageOverlay: document.getElementById('damage-overlay')
            }
        };

        // 游戏状态
        const gameState = {
            score: 0,
            health: 100,
            maxHealth: 100,
            ammo: 100,
            maxAmmo: 100,
            enemies: [],
            totalEnemies: 5,
            wave: 1,
            kills: 0,
            shotsFired: 0,
            shotsHit: 0,
            weapon: {
                name: '等离子步枪',
                mode: '自动',
                damage: 25,
                fireRate: 150,
                lastShot: 0,
                color: '#0ff'
            },
            weapons: [
                { name: '等离子步枪', damage: 25, fireRate: 150, color: '#0ff' },
                { name: '激光枪', damage: 15, fireRate: 100, color: '#f0f' },
                { name: '离子炮', damage: 50, fireRate: 800, color: '#ff0' }
            ],
            currentWeaponIndex: 0,
            player: {
                x: 0,
                y: 0,
                angle: 0,
                moving: false,
                keys: {},
                velocityX: 0,
                velocityY: 0,
                jumpVelocity: 0,
                isJumping: false,
                height: 0
            },
            projectiles: [],
            particles: [],
            radarDots: [],
            gameTime: 0,
            isPaused: false
        };

        // 初始化游戏
        function initGame() {
            const canvas = config.canvas;
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas大小
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // 初始化雷达点
            initRadarDots();
            
            // 显示开始游戏界面
            config.gameStates.start.style.display = 'flex';
            config.gameStates.over.style.display = 'none';
            config.gameStates.pause.style.display = 'none';
            
            // 开始游戏循环
            gameLoop();
        }

        // 初始化敌人
        function initEnemies() {
            gameState.enemies = [];
            gameState.totalEnemies = 5 + (gameState.wave - 1) * 2; // 每波增加2个敌人
            
            // 创建敌人位置（在画布周围）
            for (let i = 0; i < gameState.totalEnemies; i++) {
                const angle = (i / gameState.totalEnemies) * Math.PI * 2;
                const distance = 350 + Math.random() * 200;
                
                // 随机敌人类型
                const type = Math.floor(Math.random() * 3);
                let enemyConfig = {};
                
                switch(type) {
                    case 0: // 快速型
                        enemyConfig = { health: 50, speed: 3, size: 25, color: '#ff3366', damage: 5 };
                        break;
                    case 1: // 均衡型
                        enemyConfig = { health: 100, speed: 1.5, size: 35, color: '#33ff66', damage: 10 };
                        break;
                    case 2: // 重型
                        enemyConfig = { health: 200, speed: 0.8, size: 45, color: '#3366ff', damage: 20 };
                        break;
                }
                
                gameState.enemies.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance,
                    size: enemyConfig.size,
                    health: enemyConfig.health,
                    maxHealth: enemyConfig.health,
                    angle: Math.random() * Math.PI * 2,
                    speed: enemyConfig.speed,
                    type: type,
                    damage: enemyConfig.damage,
                    color: enemyConfig.color,
                    lastShot: 0,
                    shotDelay: 1500 + Math.random() * 1500
                });
            }
            
            updateEnemyCounter();
        }

        // 初始化雷达点
        function initRadarDots() {
            gameState.radarDots = [];
            
            // 创建一些随机雷达点（模拟其他目标）
            for (let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 100;
                
                gameState.radarDots.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance,
                    type: Math.random() > 0.6 ? 'enemy' : 'neutral'
                });
            }
        }

        // 游戏主循环
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (!config.gameStates.playing || gameState.isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            const canvas = config.canvas;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 清空画布
            ctx.fillStyle = '#001020';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制3D场景
            draw3DScene(ctx, width, height);
            
            // 更新游戏状态
            updateGameState(deltaTime);
            
            // 更新HUD
            updateHUD();
            
            // 更新雷达扫描
            updateRadar();
            
            // 继续游戏循环
            requestAnimationFrame(gameLoop);
        }

        // 绘制3D场景
        function draw3DScene(ctx, width, height) {
            // 绘制地板
            drawFloor(ctx, width, height);
            
            // 绘制墙壁
            drawWalls(ctx, width, height);
            
            // 绘制敌人
            drawEnemies(ctx, width, height);
            
            // 绘制子弹/粒子效果
            drawProjectiles(ctx, width, height);
            
            // 绘制天空/背景
            drawSky(ctx, width, height);
        }

        // 绘制地板
        function drawFloor(ctx, width, height) {
            const gridSize = 60;
            const horizon = height / 2;
            
            // 地板渐变
            const floorGradient = ctx.createLinearGradient(0, horizon, 0, height);
            floorGradient.addColorStop(0, '#001a33');
            floorGradient.addColorStop(0.5, '#003366');
            floorGradient.addColorStop(1, '#004488');
            
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, horizon, width, height - horizon);
            
            // 绘制网格线
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            
            // 水平线（透视）
            for (let i = 1; i < 12; i++) {
                const perspective = i / 12;
                const y = horizon + perspective * perspective * (height - horizon);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // 垂直线（透视）
            const centerX = width / 2;
            for (let i = -6; i <= 6; i++) {
                const perspective = Math.max(0.1, 1 - Math.abs(i) * 0.12);
                const x = centerX + (i * 80) * perspective;
                const startY = horizon;
                const endY = height;
                
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
        }

        // 绘制墙壁
        function drawWalls(ctx, width, height) {
            const horizon = height / 2;
            const wallHeight = 250;
            
            // 左侧墙壁
            const leftWallGradient = ctx.createLinearGradient(0, 0, width * 0.25, 0);
            leftWallGradient.addColorStop(0, '#003366');
            leftWallGradient.addColorStop(0.5, '#004488');
            leftWallGradient.addColorStop(1, '#002244');
            
            ctx.fillStyle = leftWallGradient;
            ctx.fillRect(0, horizon - wallHeight, width * 0.25, wallHeight);
            
            // 右侧墙壁
            const rightWallGradient = ctx.createLinearGradient(width * 0.75, 0, width, 0);
            rightWallGradient.addColorStop(0, '#002244');
            rightWallGradient.addColorStop(0.5, '#004488');
            rightWallGradient.addColorStop(1, '#003366');
            
            ctx.fillStyle = rightWallGradient;
            ctx.fillRect(width * 0.75, horizon - wallHeight, width * 0.25, wallHeight);
            
            // 墙壁细节
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.25)';
            ctx.lineWidth = 2;
            
            // 左侧墙壁垂直线
            for (let i = 0; i < 6; i++) {
                const x = (width * 0.25) * (i / 6);
                ctx.beginPath();
                ctx.moveTo(x, horizon - wallHeight);
                ctx.lineTo(x, horizon);
                ctx.stroke();
            }
            
            // 左侧墙壁水平线
            for (let i = 0; i < 4; i++) {
                const y = horizon - wallHeight + (wallHeight * (i / 4));
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width * 0.25, y);
                ctx.stroke();
            }
            
            // 右侧墙壁垂直线
            for (let i = 0; i < 6; i++) {
                const x = width * 0.75 + (width * 0.25) * (i / 6);
                ctx.beginPath();
                ctx.moveTo(x, horizon - wallHeight);
                ctx.lineTo(x, horizon);
                ctx.stroke();
            }
            
            // 右侧墙壁水平线
            for (let i = 0; i < 4; i++) {
                const y = horizon - wallHeight + (wallHeight * (i / 4));
                ctx.beginPath();
                ctx.moveTo(width * 0.75, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        // 绘制敌人
        function drawEnemies(ctx, width, height) {
            const horizon = height / 2;
            
            gameState.enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                // 计算敌人在屏幕上的位置
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算角度
                let angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // 将角度限制在 -π 到 π 之间
                while (angle > Math.PI) angle -= Math.PI * 2;
                while (angle < -Math.PI) angle += Math.PI * 2;
                
                // 如果敌人在视野范围内
                if (Math.abs(angle) < Math.PI / 2 && distance > 10) {
                    // 计算透视投影
                    const screenX = width / 2 + (angle * width / Math.PI);
                    const size = Math.min((enemy.size * height * 3) / distance, height * 0.3);
                    const screenY = horizon + (height / (distance + 100)) * 80;
                    
                    // 绘制敌人光晕
                    const glowGradient = ctx.createRadialGradient(screenX, screenY - size/2, 0, screenX, screenY - size/2, size);
                    glowGradient.addColorStop(0, enemy.color + '40');
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - size/2, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 敌人主体
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - size/2, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 敌人核心
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - size/2, size/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 敌人生命条背景
                    const healthPercent = enemy.health / enemy.maxHealth;
                    const barWidth = size * 1.5;
                    const barHeight = 6;
                    const barX = screenX - barWidth / 2;
                    const barY = screenY - size - 15;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
                    
                    // 生命条
                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    const healthColor = healthPercent > 0.6 ? '#0f0' : healthPercent > 0.3 ? '#ff0' : '#f00';
                    ctx.fillStyle = healthColor;
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    // 敌人类型指示
                    ctx.strokeStyle = enemy.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY - size/2, size/2 + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
        }

        // 绘制子弹/粒子效果
        function drawProjectiles(ctx, width, height) {
            const horizon = height / 2;
            
            // 绘制子弹
            gameState.projectiles.forEach(proj => {
                // 计算子弹在屏幕上的位置
                const dx = proj.x - gameState.player.x;
                const dy = proj.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算角度
                let angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // 将角度限制在 -π 到 π 之间
                while (angle > Math.PI) angle -= Math.PI * 2;
                while (angle < -Math.PI) angle += Math.PI * 2;
                
                // 如果子弹在视野范围内
                if (Math.abs(angle) < Math.PI / 2 && distance > 10) {
                    // 计算透视投影
                    const screenX = width / 2 + (angle * width / Math.PI);
                    const size = Math.max(2, 12 - distance / 60);
                    const screenY = horizon + (height / (distance + 100)) * 80;
                    
                    // 子弹光晕
                    const glowGradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, size * 2);
                    glowGradient.addColorStop(0, proj.color);
                    glowGradient.addColorStop(0.5, proj.color + '80');
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制子弹
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // 绘制粒子效果
            gameState.particles.forEach(particle => {
                // 计算粒子在屏幕上的位置
                const dx = particle.x - gameState.player.x;
                const dy = particle.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算角度
                let angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // 将角度限制在 -π 到 π 之间
                while (angle > Math.PI) angle -= Math.PI * 2;
                while (angle < -Math.PI) angle += Math.PI * 2;
                
                // 如果粒子在视野范围内
                if (Math.abs(angle) < Math.PI / 2 && distance > 10) {
                    // 计算透视投影
                    const screenX = width / 2 + (angle * width / Math.PI);
                    const size = particle.size * (1 - particle.life / particle.maxLife);
                    const screenY = horizon + (height / (distance + 100)) * 80;
                    
                    // 绘制粒子
                    ctx.globalAlpha = Math.max(0, particle.life / particle.maxLife);
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, Math.max(0, size), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
        }

        // 绘制天空/背景
        function drawSky(ctx, width, height) {
            const horizon = height / 2;
            
            // 天空渐变
            const skyGradient = ctx.createLinearGradient(0, 0, 0, horizon);
            skyGradient.addColorStop(0, '#000510');
            skyGradient.addColorStop(0.3, '#001020');
            skyGradient.addColorStop(0.7, '#001530');
            skyGradient.addColorStop(1, '#002040');
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, horizon);
            
            // 星星
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 150; i++) {
                const x = (i * 137) % width;
                const y = (i * 97) % (horizon * 0.8);
                const size = (i % 3) + 0.5;
                const opacity = 0.3 + (i % 7) * 0.1;
                
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // 远处的行星
            const planetGradient = ctx.createRadialGradient(width * 0.75, horizon * 0.25, 0, width * 0.75, horizon * 0.25, 50);
            planetGradient.addColorStop(0, 'rgba(80, 120, 200, 0.4)');
            planetGradient.addColorStop(0.7, 'rgba(60, 100, 180, 0.2)');
            planetGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = planetGradient;
            ctx.beginPath();
            ctx.arc(width * 0.75, horizon * 0.25, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // 另一个行星
            const moonGradient = ctx.createRadialGradient(width * 0.2, horizon * 0.35, 0, width * 0.2, horizon * 0.35, 35);
            moonGradient.addColorStop(0, 'rgba(180, 140, 80, 0.3)');
            moonGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = moonGradient;
            ctx.beginPath();
            ctx.arc(width * 0.2, horizon * 0.35, 35, 0, Math.PI * 2);
            ctx.fill();
        }

        // 更新游戏状态
        function updateGameState(deltaTime) {
            const currentTime = Date.now();
            gameState.gameTime += deltaTime || 16;
            
            // 更新玩家位置
            updatePlayerPosition();
            
            // 更新敌人
            updateEnemies();
            
            // 更新子弹
            updateProjectiles();
            
            // 更新粒子效果
            updateParticles();
            
            // 检查游戏结束条件
            if (gameState.health <= 0) {
                endGame(false);
            }
            
            // 检查胜利条件（当前波次完成）
            if (gameState.enemies.length === 0) {
                completeWave();
            }
        }

        // 更新玩家位置
        function updatePlayerPosition() {
            const speed = 5;
            const angle = gameState.player.angle;
            let moved = false;
            
            if (gameState.player.keys['w'] || gameState.player.keys['arrowup']) {
                gameState.player.x += Math.cos(angle) * speed;
                gameState.player.y += Math.sin(angle) * speed;
                moved = true;
            }
            if (gameState.player.keys['s'] || gameState.player.keys['arrowdown']) {
                gameState.player.x -= Math.cos(angle) * speed;
                gameState.player.y -= Math.sin(angle) * speed;
                moved = true;
            }
            if (gameState.player.keys['a'] || gameState.player.keys['arrowleft']) {
                gameState.player.x += Math.cos(angle - Math.PI/2) * speed;
                gameState.player.y += Math.sin(angle - Math.PI/2) * speed;
                moved = true;
            }
            if (gameState.player.keys['d'] || gameState.player.keys['arrowright']) {
                gameState.player.x += Math.cos(angle + Math.PI/2) * speed;
                gameState.player.y += Math.sin(angle + Math.PI/2) * speed;
                moved = true;
            }
            
            // 跳跃功能
            if (gameState.player.keys[' '] && !gameState.player.isJumping) {
                gameState.player.isJumping = true;
                gameState.player.jumpVelocity = 8;
            }
            
            // 处理跳跃
            if (gameState.player.isJumping) {
                gameState.player.height += gameState.player.jumpVelocity;
                gameState.player.jumpVelocity -= 0.5; // 重力
                
                if (gameState.player.height <= 0) {
                    gameState.player.height = 0;
                    gameState.player.isJumping = false;
                    gameState.player.jumpVelocity = 0;
                }
            }
            
            gameState.player.moving = moved;
            
            // 限制玩家移动范围
            const maxDistance = 600;
            const distance = Math.sqrt(gameState.player.x * gameState.player.x + gameState.player.y * gameState.player.y);
            if (distance > maxDistance) {
                gameState.player.x = (gameState.player.x / distance) * maxDistance;
                gameState.player.y = (gameState.player.y / distance) * maxDistance;
            }
        }

        // 更新敌人
        function updateEnemies() {
            const currentTime = Date.now();
            
            // 使用倒序遍历以安全删除
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                if (enemy.health <= 0) continue;
                
                // 敌人移动 - 追踪玩家
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                
                // 敌人朝向玩家移动
                const moveAngle = Math.atan2(dy, dx);
                enemy.angle = moveAngle;
                
                // 保持一定距离
                if (distToPlayer > 100) {
                    enemy.x += Math.cos(moveAngle) * enemy.speed;
                    enemy.y += Math.sin(moveAngle) * enemy.speed;
                } else if (distToPlayer < 80) {
                    enemy.x -= Math.cos(moveAngle) * enemy.speed * 0.5;
                    enemy.y -= Math.sin(moveAngle) * enemy.speed * 0.5;
                }
                
                // 限制敌人移动范围
                const maxDistance = 700;
                const distance = Math.sqrt(enemy.x * enemy.x + enemy.y * enemy.y);
                if (distance > maxDistance) {
                    enemy.x = (enemy.x / distance) * maxDistance;
                    enemy.y = (enemy.y / distance) * maxDistance;
                }
                
                // 敌人射击
                if (currentTime - enemy.lastShot > enemy.shotDelay && distToPlayer < 500) {
                    enemy.lastShot = currentTime;
                    
                    // 创建敌人子弹
                    const angle = Math.atan2(dy, dx);
                    gameState.projectiles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        damage: enemy.damage,
                        isEnemy: true,
                        color: '#f00'
                    });
                }
                
                // 检查子弹是否击中敌人
                for (let j = gameState.projectiles.length - 1; j >= 0; j--) {
                    const proj = gameState.projectiles[j];
                    if (proj.isEnemy) continue;
                    
                    const pdx = proj.x - enemy.x;
                    const pdy = proj.y - enemy.y;
                    const pDist = Math.sqrt(pdx * pdx + pdy * pdy);
                    
                    if (pDist < enemy.size) {
                        // 击中敌人
                        enemy.health -= proj.damage;
                        gameState.shotsHit++;
                        
                        // 创建击中效果
                        createHitEffect(enemy.x, enemy.y, proj.color);
                        
                        // 移除子弹
                        gameState.projectiles.splice(j, 1);
                        
                        // 如果敌人死亡
                        if (enemy.health <= 0) {
                            gameState.kills++;
                            gameState.score += 100 * gameState.wave;
                            
                            // 创建死亡效果
                            createExplosion(enemy.x, enemy.y, enemy.color);
                            
                            // 移除敌人
                            gameState.enemies.splice(i, 1);
                            updateEnemyCounter();
                            updateScore();
                            break; // 敌人已死亡，跳出子弹循环
                        }
                    }
                }
            }
        }

        // 更新子弹
        function updateProjectiles() {
            // 使用倒序遍历
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                // 检查子弹是否超出范围
                const distance = Math.sqrt(proj.x * proj.x + proj.y * proj.y);
                if (distance > 1000) {
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                // 如果是敌人子弹，检查是否击中玩家
                if (proj.isEnemy) {
                    const dx = proj.x - gameState.player.x;
                    const dy = proj.y - gameState.player.y;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distToPlayer < 25) {
                        // 击中玩家
                        takeDamage(proj.damage);
                        gameState.projectiles.splice(i, 1);
                        createHitEffect(gameState.player.x, gameState.player.y, '#f00');
                    }
                }
            }
        }

        // 更新粒子效果
        function updateParticles() {
            // 使用倒序遍历
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98; // 摩擦力
                particle.vy *= 0.98;
                particle.life--;
                
                // 移除死亡的粒子
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        // 创建爆炸效果
        function createExplosion(x, y, color) {
            const particleCount = 20 + Math.floor(Math.random() * 10);
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.5;
                const speed = 3 + Math.random() * 5;
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 6,
                    color: color,
                    life: 40 + Math.random() * 30,
                    maxLife: 70
                });
            }
        }

        // 完成波次
        function completeWave() {
            if (gameState.enemies.length > 0) return;
            
            gameState.wave++;
            
            // 波次奖励
            const waveBonus = gameState.wave * 200;
            gameState.score += waveBonus;
            
            // 恢复部分生命和能量
            gameState.health = Math.min(gameState.maxHealth, gameState.health + 30);
            gameState.ammo = gameState.maxAmmo;
            
            showMessage(`第 ${gameState.wave - 1} 波完成! 奖励: ${waveBonus} 分`);
            
            // 延迟后开始下一波
            setTimeout(() => {
                if (config.gameStates.playing) {
                    showMessage(`第 ${gameState.wave} 波开始! 敌人数量: ${5 + (gameState.wave - 1) * 2}`);
                    initEnemies();
                    updateHUD();
                }
            }, 2000);
        }

        // 更新HUD
        function updateHUD() {
            // 更新生命值
            const healthPercent = gameState.health / gameState.maxHealth;
            config.hud.healthText.textContent = Math.max(0, Math.floor(gameState.health));
            config.hud.healthBar.style.width = `${healthPercent * 100}%`;
            
            // 生命条颜色变化
            if (healthPercent > 0.6) {
                config.hud.healthBar.style.background = 'linear-gradient(90deg, #00cc44, #00ff80)';
            } else if (healthPercent > 0.3) {
                config.hud.healthBar.style.background = 'linear-gradient(90deg, #cc8800, #ffaa00)';
            } else {
                config.hud.healthBar.style.background = 'linear-gradient(90deg, #cc0000, #ff3333)';
            }
            
            // 更新能量
            const ammoPercent = gameState.ammo / gameState.maxAmmo;
            config.hud.ammoText.textContent = Math.max(0, Math.floor(gameState.ammo));
            config.hud.ammoBar.style.width = `${ammoPercent * 100}%`;
            
            // 更新武器信息
            config.hud.weaponName.textContent = gameState.weapon.name;
            config.hud.weaponMode.textContent = gameState.weapon.mode;
            config.hud.weaponDamage.textContent = gameState.weapon.damage;
            
            // 更新波次
            config.hud.waveCount.textContent = gameState.wave;
        }

        // 更新雷达
        function updateRadar() {
            // 清除旧的点
            const existingDots = document.querySelectorAll('.radar-dot:not(.static)');
            existingDots.forEach(dot => dot.remove());
            
            // 添加敌人位置到雷达
            gameState.enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                const radar = document.getElementById('radar');
                const radarDot = document.createElement('div');
                radarDot.className = 'radar-dot';
                radarDot.style.left = `calc(50% + ${enemy.x / 8}px)`;
                radarDot.style.top = `calc(50% + ${enemy.y / 8}px)`;
                radarDot.style.backgroundColor = '#f00';
                radarDot.style.width = '8px';
                radarDot.style.height = '8px';
                radar.appendChild(radarDot);
            });
        }

        // 更新敌人计数器
        function updateEnemyCounter() {
            config.hud.enemyCount.textContent = gameState.enemies.length;
        }

        // 更新分数
        function updateScore() {
            config.hud.scoreValue.textContent = gameState.score;
        }

        // 显示消息
        function showMessage(text) {
            const message = config.elements.message;
            message.textContent = text;
            message.style.opacity = 1;
            message.classList.add('show');
            
            setTimeout(() => {
                message.style.opacity = 0;
                message.classList.remove('show');
            }, 2500);
        }

        // 创建击中效果
        function createHitEffect(x, y, color) {
            // 屏幕击中效果
            config.elements.hitEffect.style.opacity = 0.8;
            config.elements.hitIndicator.style.opacity = 1;
            
            setTimeout(() => {
                config.elements.hitEffect.style.opacity = 0;
                config.elements.hitIndicator.style.opacity = 0;
            }, 100);
            
            // 创建粒子效果
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 4,
                    color: color,
                    life: 15 + Math.random() * 20,
                    maxLife: 35
                });
            }
        }

        // 玩家受到伤害
        function takeDamage(amount) {
            gameState.health -= amount;
            if (gameState.health < 0) gameState.health = 0;
            
            // 屏幕伤害效果
            config.elements.damageOverlay.style.background = 
                `radial-gradient(circle, transparent 30%, rgba(255, 0, 0, ${Math.min(0.5, amount / 50)}) 100%)`;
            
            setTimeout(() => {
                config.elements.damageOverlay.style.background = 
                    'radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0) 100%)';
            }, 200);
            
            // 创建击中效果
            createHitEffect(gameState.player.x, gameState.player.y, '#f00');
            
            // 更新HUD
            updateHUD();
        }

        // 玩家射击
        function playerShoot() {
            const currentTime = Date.now();
            
            // 检查是否可以射击
            if (currentTime - gameState.weapon.lastShot < gameState.weapon.fireRate) return;
            
            // 检查是否有弹药
            if (gameState.ammo <= 0) {
                showMessage("能量不足! 按 R 填充");
                return;
            }
            
            // 消耗弹药
            const ammoCost = gameState.weapon.mode === '狙击' ? 15 : gameState.weapon.mode === '散射' ? 8 : 3;
            gameState.ammo -= ammoCost;
            if (gameState.ammo < 0) gameState.ammo = 0;
            
            // 更新上次射击时间
            gameState.weapon.lastShot = currentTime;
            gameState.shotsFired++;
            
            // 准星效果
            config.elements.crosshair.classList.add('shooting');
            setTimeout(() => config.elements.crosshair.classList.remove('shooting'), 100);
            
            // 创建子弹
            const bulletCount = gameState.weapon.mode === '散射' ? 5 : 1;
            const spread = gameState.weapon.mode === '散射' ? 0.3 : 0.02;
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = gameState.player.angle + (Math.random() - 0.5) * spread;
                
                gameState.projectiles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(angle) * 20,
                    vy: Math.sin(angle) * 20,
                    damage: gameState.weapon.damage / (bulletCount > 1 ? 2.5 : 1),
                    isEnemy: false,
                    color: gameState.weapon.color
                });
            }
            
            // 创建射击效果
            for (let i = 0; i < 5; i++) {
                const angle = gameState.player.angle + (Math.random() - 0.5) * 0.5;
                gameState.particles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(angle) * 12 + (Math.random() - 0.5) * 4,
                    vy: Math.sin(angle) * 12 + (Math.random() - 0.5) * 4,
                    size: 2 + Math.random() * 3,
                    color: gameState.weapon.color,
                    life: 8 + Math.random() * 10,
                    maxLife: 18
                });
            }
            
            // 更新HUD
            updateHUD();
        }

        // 重新装弹
        function reload() {
            if (gameState.ammo >= gameState.maxAmmo) {
                showMessage("能量已满!");
                return;
            }
            
            gameState.ammo = gameState.maxAmmo;
            showMessage("能量已充满!");
            updateHUD();
        }

        // 切换武器模式
        function toggleWeaponMode() {
            const modes = ['自动', '散射', '狙击'];
            const currentIndex = modes.indexOf(gameState.weapon.mode);
            const nextIndex = (currentIndex + 1) % modes.length;
            
            gameState.weapon.mode = modes[nextIndex];
            
            // 根据模式调整武器属性
            if (gameState.weapon.mode === '散射') {
                gameState.weapon.damage = 12;
                gameState.weapon.fireRate = 400;
            } else if (gameState.weapon.mode === '狙击') {
                gameState.weapon.damage = 60;
                gameState.weapon.fireRate = 1200;
            } else {
                gameState.weapon.damage = 25;
                gameState.weapon.fireRate = 150;
            }
            
            showMessage(`武器模式: ${gameState.weapon.mode}`);
            updateHUD();
        }

        // 切换武器
        function switchWeapon(weaponIndex) {
            if (weaponIndex >= 0 && weaponIndex < gameState.weapons.length) {
                gameState.currentWeaponIndex = weaponIndex;
                const weapon = gameState.weapons[weaponIndex];
                gameState.weapon.name = weapon.name;
                gameState.weapon.damage = weapon.damage;
                gameState.weapon.fireRate = weapon.fireRate;
                gameState.weapon.color = weapon.color;
                
                showMessage(`武器: ${weapon.name}`);
                updateHUD();
            }
        }

        // 开始游戏
        function startGame() {
            console.log("开始游戏");
            config.gameStates.playing = true;
            config.gameStates.start.style.display = 'none';
            config.gameStates.over.style.display = 'none';
            config.gameStates.pause.style.display = 'none';
            
            // 重置游戏状态
            gameState.score = 0;
            gameState.health = 100;
            gameState.ammo = 100;
            gameState.wave = 1;
            gameState.kills = 0;
            gameState.shotsFired = 0;
            gameState.shotsHit = 0;
            gameState.player.x = 0;
            gameState.player.y = 0;
            gameState.player.angle = 0;
            gameState.player.height = 0;
            gameState.player.isJumping = false;
            gameState.player.jumpVelocity = 0;
            gameState.projectiles = [];
            gameState.particles = [];
            
            // 重置武器
            gameState.currentWeaponIndex = 0;
            const weapon = gameState.weapons[0];
            gameState.weapon.name = weapon.name;
            gameState.weapon.damage = weapon.damage;
            gameState.weapon.fireRate = weapon.fireRate;
            gameState.weapon.color = weapon.color;
            gameState.weapon.mode = '自动';
            gameState.weapon.lastShot = 0;
            
            // 初始化敌人
            initEnemies();
            
            // 更新HUD
            updateScore();
            updateHUD();
            updateEnemyCounter();
            
            // 锁定指针
            config.canvas.requestPointerLock();
            
            showMessage("游戏开始! 消灭所有敌人!");
        }

        // 结束游戏
        function endGame(isVictory) {
            config.gameStates.playing = false;
            document.exitPointerLock();
            
            // 计算命中率
            const accuracy = gameState.shotsFired > 0 
                ? Math.round((gameState.shotsHit / gameState.shotsFired) * 100) 
                : 0;
            
            // 显示统计
            document.getElementById('kill-count').textContent = gameState.kills;
            document.getElementById('final-wave').textContent = gameState.wave;
            document.getElementById('accuracy').textContent = accuracy + '%';
            document.getElementById('final-score').textContent = `得分: ${gameState.score}`;
            
            // 设置游戏结束标题
            if (isVictory) {
                document.getElementById('game-over-title').textContent = "任务完成!";
                document.getElementById('game-over-subtitle').textContent = "所有敌人已被消灭!";
            } else {
                document.getElementById('game-over-title').textContent = "游戏结束";
                document.getElementById('game-over-subtitle').textContent = "你在战斗中倒下了";
            }
            
            // 显示游戏结束界面
            config.gameStates.over.style.display = 'flex';
        }

        // 切换暂停
        function togglePause() {
            if (!config.gameStates.playing) return;
            
            gameState.isPaused = !gameState.isPaused;
            
            if (gameState.isPaused) {
                config.gameStates.pause.style.display = 'flex';
                document.exitPointerLock();
            } else {
                config.gameStates.pause.style.display = 'none';
                config.canvas.requestPointerLock();
            }
        }

        // 事件监听器
        function setupEventListeners() {
            const canvas = config.canvas;
            
            // 鼠标移动 - 控制视角
            document.addEventListener('mousemove', (e) => {
                if (!config.gameStates.playing || gameState.isPaused) return;
                if (document.pointerLockElement !== canvas) return;
                
                const sensitivity = 0.003;
                gameState.player.angle += e.movementX * sensitivity;
                
                // 限制角度在合理范围内
                if (gameState.player.angle > Math.PI) gameState.player.angle -= Math.PI * 2;
                if (gameState.player.angle < -Math.PI) gameState.player.angle += Math.PI * 2;
            });
            
            // 鼠标点击 - 射击
            canvas.addEventListener('mousedown', (e) => {
                if (!config.gameStates.playing || gameState.isPaused) return;
                
                if (e.button === 0) { // 左键
                    playerShoot();
                }
            });
            
            // 保持射击（自动模式）
            let isMouseDown = false;
            canvas.addEventListener('mousedown', () => isMouseDown = true);
            canvas.addEventListener('mouseup', () => isMouseDown = false);
            
            // 射击检测循环
            setInterval(() => {
                if (isMouseDown && config.gameStates.playing && !gameState.isPaused && 
                    gameState.weapon.mode === '自动') {
                    playerShoot();
                }
            }, 16);
            
            // 键盘控制
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                gameState.player.keys[key] = true;
                gameState.player.keys[e.key] = true;
                
                if (!config.gameStates.playing || gameState.isPaused) {
                    if (key === 'escape') {
                        togglePause();
                    }
                    return;
                }
                
                switch(key) {
                    case 'r': // 重新装弹
                        reload();
                        break;
                    case 'f': // 切换武器模式
                        toggleWeaponMode();
                        break;
                    case '1': // 切换武器1
                        switchWeapon(0);
                        break;
                    case '2': // 切换武器2
                        switchWeapon(1);
                        break;
                    case '3': // 切换武器3
                        switchWeapon(2);
                        break;
                    case 'escape': // 暂停游戏
                        togglePause();
                        break;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                gameState.player.keys[key] = false;
                gameState.player.keys[e.key] = false;
            });
            
            // 按钮事件
            document.getElementById('start-btn').addEventListener('click', startGame);
            
            document.getElementById('restart-btn').addEventListener('click', () => {
                config.gameStates.over.style.display = 'none';
                startGame();
            });
            
            document.getElementById('menu-btn').addEventListener('click', () => {
                config.gameStates.over.style.display = 'none';
                config.gameStates.start.style.display = 'flex';
                config.gameStates.playing = false;
            });
            
            document.getElementById('resume-btn').addEventListener('click', () => {
                togglePause();
            });
            
            document.getElementById('quit-btn').addEventListener('click', () => {
                gameState.isPaused = false;
                config.gameStates.pause.style.display = 'none';
                config.gameStates.start.style.display = 'flex';
                config.gameStates.playing = false;
            });
            
            // 窗口大小调整
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
            
            // 请求指针锁定（点击游戏区域时）
            canvas.addEventListener('click', () => {
                if (config.gameStates.playing && !gameState.isPaused) {
                    canvas.requestPointerLock();
                }
            });
        }

        // 初始化
        window.onload = function() {
            console.log("页面加载完成，初始化游戏");
            initGame();
            setupEventListeners();
        };
    </script>
</body>
</html>
